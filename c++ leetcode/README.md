
# 前言

**平衡好刷题和总结，不要沉浸于刷了几道题**

**基础最重要，不要沉浸于做难题怪题**

**算法好不代表技术好，技术好不代表总体好**

**对于每种算法有总结，对一类算法也要有总结**

如：对一组数据进行排序

最先想到快速排序，但是应该考虑数据的特点

有没有可能包含大量重复元素?  三路快排

是否大部分数据距离它正确的位置很近?是否近乎有序?  插入排序

是否数据的取值范围非常有限?比如对学生成绩排序  计数排序

是否需要稳定排序?  快速排序不稳定 可以用归并排序

是否是使用链表存储的?  链表存储可以用归并排序

数据的大小是否可以装载在内存里?  如果不在内存中排序要用外排序的方法

# 1.算法复杂度分析

## 1.1 大O
O(sqrt(n)) O(n) O(nlog) O(n^2) O(n^3) O(2^n)

有一个字符串数组，先对每个字符串进行字母序排序， 再对整个字符串数组进行字典序的排序，分析时间复杂度

假设数组有n个字符串，最长为s，排序算法的复杂度选择一般情况下最好的复杂度O(nlogn)

对每个字符串进行排序 O(n*slogs)  

对数组进行排序 O(nlogn*s)  排序中的nlog是比较的次数 数字排序 两个数字比较一次就好 这里是字符串排序 每个字符串至多比较s次 因此要乘s

logn 代表任意底的对数 如log2_n log10_n  因为他们差的只是常数项 log2_N = log2_10 * log_10N  

log2_n代表 n这个数通过这么多次除2操作变成1

log10_n代表 n这个数通过这么多次除10操作变成1

## 1.2 数据规模
1s内

O(n)大约可以处理10^8 即亿级的数据

O(n^2)大约可以处理10^4 即万级的数据

O(nlogn)大约可以处理10^7 即千万级的数据

当进行的是比较复杂的操作时，可处理的数据规模再除10

## 1.3 空间复杂度
O(n) 数据增多 需要开辟的空间也跟着线性增多 

O(1) 数据增多 需要的空间不变

递归算法中，要将递归的状态压入系统栈中，因此递归深度有多深，就需要多少额外的空间

## 1.4 递归时间复杂度分析
不是递归就一定是O(nlogn)的复杂度

只进行一次递归调用时 复杂度就是递归深度 *每次递归操作的数据规模 *每次操作数据的复杂度

比如二分查找 深度是logn 每次操作是比较两个数 总的复杂度是O(logn)

比如递归求前n个数之和 深度是n 每次操作是加一个数  总的复杂度是O(n)

如果要进行多次递归调用，要计算递归的次数，可以尝试画递归树，然后节点个数就是递归次数 

复杂度 = 递归次数 *每次递归操作的数据规模 *每次操作数据的复杂度 = 递归层数 *每层操作的数据规模 *每次操作数据的复杂度

比如归并排序中，把序列不断分为两部分，最后进行两部分归并，画成递归树，有logn层 每层操作的数据规模都一样 都是n 操作数据都是排序 因此递归排序的复杂度是O(nlogn)

## 1.5 均摊复杂度分析
一个操作偶尔会有不同复杂度的情况，那么这个操作的复杂度就要分析它的均摊复杂度

比如动态数组中插入元素，每次是O(1) 但是容量不够时要扩容一倍  然后把原来的赋值到新的数组中 复杂度是O(n) 

这里n次O(1)的插入后有一次O(n)的扩容然后执行一个O(1)的插入  即n+1次插入的总操作是2n+1次 平均每次还是O(1)

## 1.6 复杂度震荡
一个动态数组可以容量capacity个元素 当数组满了之后再进行插入 会开辟一个2*capacity的数组 然后赋值给新数组 删除原来的数组 均摊复杂度仍然是O(1)

然后这个数组删除元素，当删除到元素个数是capacity时，为了防止空间浪费，可以复制到一个容量为capacity的数组中 均摊复杂度仍是O(1)

但是这样会出现一个复杂度震荡的情况 就是此时插入一个元素需要开辟空间 复杂度O(n) 紧接着马上又删除一个元素 又要回收空间 复杂度O(n)  反复在边界进行操作 使得复杂度变得无法分析 

因此一般元素个数变成容量的1/4时才回收空间，而且是回收容量的1/2

# 2.数组

# 3.查找表

# 4.链表

# 5.栈 队列 优先队列

# 6.二叉树和递归

# 7.递归和回溯法

# 8.动态规划基础

# 9.贪心算法

