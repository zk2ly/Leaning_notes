
# 前言

**平衡好刷题和总结，不要沉浸于刷了几道题**

**基础最重要，不要沉浸于做难题怪题**

**算法好不代表技术好，技术好不代表总体好**

**对于每种算法有总结，对一类算法也要有总结**

如：对一组数据进行排序

最先想到快速排序，但是应该考虑数据的特点

有没有可能包含大量重复元素?  三路快排

是否大部分数据距离它正确的位置很近?是否近乎有序?  插入排序

是否数据的取值范围非常有限?比如对学生成绩排序  计数排序

是否需要稳定排序?  快速排序不稳定 可以用归并排序

是否是使用链表存储的?  链表存储可以用归并排序

数据的大小是否可以装载在内存里?  如果不在内存中排序要用外排序的方法

# 1.算法复杂度分析

## 1.1 大O
O(sqrt(n)) O(n) O(nlog) O(n^2) O(n^3) O(2^n)

有一个字符串数组，先对每个字符串进行字母序排序， 再对整个字符串数组进行字典序的排序，分析时间复杂度

假设数组有n个字符串，最长为s，排序算法的复杂度选择一般情况下最好的复杂度O(nlogn)

对每个字符串进行排序 O(n*slogs)  

对数组进行排序 O(nlogn*s)  排序中的nlog是比较的次数 数字排序 两个数字比较一次就好 这里是字符串排序 每个字符串至多比较s次 因此要乘s

logn 代表任意底的对数 如log2_n log10_n  因为他们差的只是常数项 log2_N = log2_10 * log_10N  

log2_n代表 n这个数通过这么多次除2操作变成1

log10_n代表 n这个数通过这么多次除10操作变成1

## 1.2 数据规模
1s内

O(n)大约可以处理10^8 即亿级的数据

O(n^2)大约可以处理10^4 即万级的数据

O(nlogn)大约可以处理10^7 即千万级的数据

当进行的是比较复杂的操作时，可处理的数据规模再除10

## 1.3 空间复杂度
O(n) 数据增多 需要开辟的空间也跟着线性增多 

O(1) 数据增多 需要的空间不变

递归算法中，要将递归的状态压入系统栈中，因此递归深度有多深，就需要多少额外的空间

## 1.4 递归时间复杂度分析
不是递归就一定是O(nlogn)的复杂度

只进行一次递归调用时 复杂度就是递归深度 *每次递归操作的数据规模 *每次操作数据的复杂度

比如二分查找 深度是logn 每次操作是比较两个数 总的复杂度是O(logn)

比如递归求前n个数之和 深度是n 每次操作是加一个数  总的复杂度是O(n)

如果要进行多次递归调用，要计算递归的次数，可以尝试画递归树，然后节点个数就是递归次数 

复杂度 = 递归次数 *每次递归操作的数据规模 *每次操作数据的复杂度 = 递归层数 *每层操作的数据规模 *每次操作数据的复杂度

比如归并排序中，把序列不断分为两部分，最后进行两部分归并，画成递归树，有logn层 每层操作的数据规模都一样 都是n 操作数据都是排序 因此递归排序的复杂度是O(nlogn)

## 1.5 均摊复杂度分析
一个操作偶尔会有不同复杂度的情况，那么这个操作的复杂度就要分析它的均摊复杂度

比如动态数组中插入元素，每次是O(1) 但是容量不够时要扩容一倍  然后把原来的赋值到新的数组中 复杂度是O(n) 

这里n次O(1)的插入后有一次O(n)的扩容然后执行一个O(1)的插入  即n+1次插入的总操作是2n+1次 平均每次还是O(1)

## 1.6 复杂度震荡
一个动态数组可以容量capacity个元素 当数组满了之后再进行插入 会开辟一个2*capacity的数组 然后赋值给新数组 删除原来的数组 均摊复杂度仍然是O(1)

然后这个数组删除元素，当删除到元素个数是capacity时，为了防止空间浪费，可以复制到一个容量为capacity的数组中 均摊复杂度仍是O(1)

但是这样会出现一个复杂度震荡的情况 就是此时插入一个元素需要开辟空间 复杂度O(n) 紧接着马上又删除一个元素 又要回收空间 复杂度O(n)  反复在边界进行操作 使得复杂度变得无法分析 

因此一般元素个数变成容量的1/4时才回收空间，而且是回收容量的1/2

# 2.数组
## 2.1 元素指针
283.移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
```c++
// 第一感觉 用两个指针i j  i遍历数组 j记录当前赋值位置 非零则赋值 遍历完毕后 j及其后面的都赋值为0
// 算法遍历了一遍数组 时间O(n) 空间O(1)
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        unsigned j = 0; // 当前要赋值的位置
        for(unsigned i=0; i< nums.size(); i++)
            if(nums[i])
                nums[j++] = nums[i];

        while(j<nums.size()){
            nums[j++] = 0;
        }
    }
};
```
作业:

26.[0,j]元素都不重复 当前元素nums[i]！=nums[j]时加入[0,j]中 否则查看下一个元素 O(n) 空间O(1)

27.同26

80.同26 但是要比较nums[j] 和 nums[j-1]两个元素
## 2.2 三路快排partition思路的应用
75.颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

示例 ：
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]


提示：
n == nums.length
1 <= n <= 300
nums[i] 为 0、1 或 2

```c++
// 第一感觉 计数排序 编译一遍数组 记录0,1,2的数量  再遍历一遍数组 重新给数组赋值
// 时间O(n) 空间O(1)
class Solution {
public:
    // 编译一遍数组 记录0,1,2的数量  再遍历一遍数组 重新给数组赋值
    void sortColors(vector<int>& nums) {
        int x=0,y=0,z=0;
        for(unsigned i=0; i<nums.size(); i++)
            if(nums[i]==0)
                x++;
            else if(nums[i]==1)
                y++;
            else
                z++;
            
        int i=0;
        while(x--) nums[i++] = 0;
        while(y--) nums[i++] = 1;
        while(z--) nums[i++] = 2;
    }
};
```
如果要求只遍历一遍数组，可以用快速排序，因为有大量重复元素，用三路快排
```c++
class Solution {
public:
    // 遍历数组 分为小于1，等于1，大于1三部分 
    // [0,zero)小于1 [zero, i)等于1 (two,n-1] 大于1
    void sortColors(vector<int>& nums) {
        int zero =0, two = nums.size()-1;

        for(int i =0; i<=two; ){
            if(nums[i]==0)
                swap(nums[zero++], nums[i++]);
            else if(nums[i]==1)
                i++;
            else if(nums[i]==2)
                swap(nums[i], nums[two--]);
        }
    }
};
```
作业：

88 第一感觉是开辟一个数组 每次把小的元素放进去 最后赋值给nums1 空间O(n+m)； 优化是从后方前放 每次放大的

215 先整体排序，再选第k个 O(nlogn); 用快排的思想，当p的位置刚好是k时返回 否则到其中一侧寻找 第一次遍历n  第二次n/2 最后一次 1 是一个等比数列 和为2n-1 O(n); 原快排因为两边都要再排序 不是到一遍寻找 树高logn  每层遍历n个元素 所有是O(nlgn); 维护一个k个元素的小根堆，先用前k个元素建堆，然后遍历k+1-n-1，如果大于堆首则替换堆首并下移 整体遍历一遍数组，遍历中不管是建堆还是替换 都要用到shiftDown，操作对象是一个logk的堆，时间复杂是O(nlogk)

**有中间数的数组重排问题，都可以考虑使用快速排序**
## 2.3 对撞指针
167.两数之和 II 

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

示例:
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```c++
// 第一感觉 两个指针一前一后 相加大了 右指针左移  相加小了 左指针右移
// 时间O(n) 空间O(1)
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res;

        if(numbers.size() == 0)
            return res;

        int i=0, j=numbers.size()-1;
        while(i<j){
            if(numbers[i] + numbers[j] == target){
                res.push_back(i+1);
                res.push_back(j+1);
                break;
            }
            else if(numbers[i] + numbers[j] > target)
                j--;
            else
                i++;
        }

        return res;
    }
};
```
作业:

11 指针对撞 关键是要想清楚 只有向中间移动短的指针 容量才有可能增加 向中间移动长的指针 底边-1 高保持不变或者变小

125 isalnum判断是不是数字或字母 tolower把大写字母变小写 其他不变 最重要的是每次访问数组前都要判断是否越界
## 2.4 滑动窗口
209.长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：
输入：s = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

```c++
// 维护滑动窗口[i,j] 且res保存了[0,j]中>=s的最小连续数组的长度 如果和>=s  i++  如果和<s j++
class Solution {
public:
    // 维护滑动窗口[i,j] 
    // 如果[i,j]元素和sum>=s  i++  如果和sum<s j++  
    int minSubArrayLen(int s, vector<int>& nums) {
        int i=0, j=-1;
        int sum=0;
        int res = nums.size() + 1;

        while(i < nums.size()){
            if(j+1<nums.size() && sum<s)
                sum += nums[++j];
            else  // j 是最后一个元素 或者 sum >=s
                sum -= nums[i++];

            if(sum >= s)
                res = min(res, j-i+1);
        }

        if(res == nums.size()+1)
            return 0;
        return res;
    }
};
```
作业:

76 用need[128]记录需要的元素 负数表示多余的 needCnt记录还需要多少t中元素 如果needCnt==0 从左侧缩小窗口(不能缩没了) 缩小完后判断是否更新start和length 然后删除左侧元素使得needCnt变为1
## 2.5 在滑动窗口中做记录
3.无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

示例 4:
输入: s = ""
输出: 0
 

提示：
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```c++
// 滑动窗口[l,r]内没有重复字符 s保存窗口中有的字符 如果当前字符不包含其中 r++ 如果包含其中 l++直到不包含
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l=0, r=-1;  // 初始没有字符[0,-1]
        int res = 0;
        bool u[128]{false}; 

        // l==0 r==-1开始 
        // l==n  r==n-1结束
        while(l<s.size()){
            if(!u[s[r+1]] && r+1 < s.size()){
                r++;
                u[s[r]] = true;
                res = max(res, r-l+1); 
            }
            else{  // r+1这个元素包含在窗口中
                u[s[l]] = false;
                l++;
            }
        }
        return res;
    }
};
```

# 3.查找表
## 3.1 set的使用
349 给定两个数组，编写一个函数来计算它们的交集。

示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 
说明：
输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。
```c++
class Solution {
public:
    // set1保存nums1中的元素 遍历nums2 保存交集到set2中
    // 时间O(nlogn) 因为使用二叉搜索树实现 查找和插入都是logn  空间O(n)
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        set<int> set1(nums1.begin(), nums1.end());
        set<int> set2;

        for(int i=0; i<nums2.size();i++)
            if(set1.find(nums2[i]) != set1.end())
                set2.insert(nums2[i]);
        
        vector<int> v(set2.begin(), set2.end());

        return v;
    }
};
```
## 3.2 map的使用
350 两个数组的交集 II
给定两个数组，编写一个函数来计算它们的交集。

示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
 

说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。
```c++
class Solution {
public:
    // map1保存nums1的键值对 遍历nums2 如果在map1中找到了 放入vec中 并且map1对应--
    // 时间O(nlogn) 空间O(n)
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        map<int,int> map1;
        vector<int> vec;

        for(int i=0; i<nums1.size(); i++)
            map1[nums1[i]] +=1;
        
        for(int i=0; i<nums2.size(); i++)
            if(map1[nums2[i]]>0){
                vec.push_back(nums2[i]);
                map1[nums2[i]]-=1;
            }

        return vec;
    }
};
```
## 3.3 set和map不同的底层实现
set和map底层用树实现 最大的优点是有序性 但是操作都是logn级别的 还有另一种哈希表的实现 unordered_set和unordered_map 操作都是O(1)级别的 但是无序

作业：
136 可以用哈希表即unordered_map记录 然后遍历map选出该数，时空都是O(n)；还可以用异或运算，因为自己和自己异或为0，0和任何数异或等于数本身，空间O(1)

242 用int数组实现哈希表即可 如果不知道字符有多少种 可以用unordered_map

202 建立一个私有函数求下一个数是什么  不断的求下一个数 直至出现这两种情况:1.等于1 说明是快乐数 2.出现已经出现过的数字 说明会无线循环下去 不会出现1 不是快乐数 因此需要一个集合来保存出现过的数字
这种方法利用集合判断数字是否出现循环 也可以用快慢指针判断 慢指针每次走一步 快指针每次走两步  如果最后重合了 说明有循环 不是快乐数

290 这是一个双射的题目 即保证字母到单词的一一映射 可以用map建立字母到单词的映射  但是不能保证映射唯一  所以用set保证每个单词只能用一次 具体的：用stringstream拆分单词字符串 遍历字母字符串 建立map<char,string>的映射 如果有map[c]判断单词是否一致 如果没有map[c]要令map[c]=str 但是为了避免不同的c对应同一个str(map只保证了一个c对应一个str  没有保证一个str对应一个c) 要提前判断str是否在集合set中  另外还要注意pattern和s的长度要一致 即c和str的个数要一致

205 和290一样 要求一一映射
## 3.4 查找表的经典问题-两数之和
1 遍历数组 在哈希表map中寻找target-nums[i] 如果有 返回下标值 没有的话 添加到哈希表中 这样保证了不会用同一个元素相加 并且如果这个元素是要求的两个元素之一 即使先出现不被匹配 第二个出现时也会匹配

作业

15 先排序 然后用指针k遍历数组 每次到k的右边用双指针i=k+1和j=nums.size()-1去判断当前的数相加是否为0 如果为0 则加入res中并且同时向中间移动 大于0则移动j 小于0则移动i 为了避免相同的组合 每次要判断当前的k是否和前一个相同 如果相同 那么这个k的结果一定是被前一个的结果所包含的 因此跳过 

16 和15一致 先排序 遍历nums[k] 每次有左右指针i=k+1 j=nums.size()-1 判断sum=nums[k]+nums[i]+nums[j]和target的差距 更近则更新ans使其等于当前的sum 然后判断sum和target的关系 相等就返回 否则移动指针  这里和15不同的是 不需要对i和j去重 15要去重是因为当前的k i j已经满足相加等于0了 把这个三元组加入res中 之后不能再使用这个三元组了 因此i j都要移动 但是这里是k i j的和与target更小 但是不代表 基于i或者j还有更小的选择 因此这里不能对i j去重 

18 和上面两题一样 加一层循环即可  可以看代码看看怎么剪枝的

## 3.5 灵活选择键值
454 A[i]+B[j] 放入map中 然后查看C[i]+D[j]的相反数在不在map中 如果在 统计个数  

447 对于点points[i]  遍历除i之外的其他点points[j] 计算两点之间的距离d 如果map[d]存在 则ans+=map[d] 然后++map[d] 否则直接++map[d] 此时得到的是以i为中心 分前后的飞镖  因此最后要返回ans*2 

作业
49  主要是要找到一个键值可以表示异构的字符串 然后把这些字符串都放到这个键值下面。 1.异构字符串排序后都一样 所以可以用排序后的字符串做键值  2.取26个质数  因为质数任意质数的积一定不同 所以可以用键值 这里要注意相乘可能越界 用long long

149 可以使用斜率作为map的键 要注意几个地方：1.平行于x的线斜率都是0  但是不共线 平行于y的线斜率都是无穷大 但是不共线 ，因此不能直接用斜率作为区分 可以用<dx,dy>作为斜率 但是之前必须要约分 即2/4约为1/2 才能保证斜率相同的有相同的键  2.可能出现重复点的情况 因此先要判断点是不是和当前的nums[i]重复 如果重复则记录 否则才计算斜率 保存到map中  3.随时记录map中最大的值是多少 可以随时知道 对于当前的nums[i]对多有多少其他点和他共线  而不用最后统计完了去遍历map

## 3.6 查找表和滑动窗口
219 要求i和j的差至多为k 也就是说滑动窗口为[l,l+k]即窗口中至多有k+1个元素 遍历nums[i] 并保存到set中 如果此时set中已经有了这个数 返回true  如果没有就加入到set中 当set的大小变成k+1时 滑动窗口左侧要弹出一个元素 即erase(nums[i-k]) 

## 3.7 查找表用二分搜索树实现的顺序性
220 和219相似 用set来维护一个[i-k,i]的滑动窗口 遍历nums[i] 要在set中找到一个数于他的差的绝对值不超过t 即距离nums[i]不超过t 即这个数处于 nums[i]-t 和nums[i]+t之间 可以用有序的set中的lower_bound方法找到大于等于nums[i]-t的第一个元素 如果这个元素存在并且小于等于nums[i]+t 那么返回true  

# 4.链表
```c++
struct ListNode{
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *p) : val(x), next(p) {}
};
```
## 4.1 穿针引线
206 反转链表 令当前的结点cur指向前一个结点pre的时候 会导致后一个结点丢失 因此每次在指之前 要用nex记录后一个结点 指完之后 cur和pre都后移 直到cur等于空 说明已经全部返回完了 

92 反转部分链表 链表分为三部分 A->B->C 先翻转B 然后再拼接 因此要记录A的最后一个结点 和 B的最后一个结点 B翻转后的最后一个结点就是此时B的第一个结点 即第m个结点  这里为了防止A不存在 没有next指针 因此要设置虚拟头节点 C可以不存在

83 删除相同结点  对于当前结点cur 如果他和他的后继都存在 那么判断值是否相同 如果相同 令cur指向更下一个结点 否则 cur向后移动一位

86 分隔链表为大小两部分 维护两个链表small和large分别保存小于x和大于等于x的结点  首先创建两个头结点并记录  然后遍历结点cur时 如果值小于x则加入到small中 否则加入large中 两个链表始终维护尾指针用于插入 最后令small尾指针指向large的除头指针外第一个元素 large尾指针指向空 返回small头指针的下一个元素即可 

2 链表相加 cur1和cur2相加并加上上一个进位得到此时的值val val%10就是这一位的数 val/10就是下一位的进位 此时创建一个结点保存val%10 并让创建的尾指针指向它 如果有一个链表没有结点了 那么值就取0 最后看还有没有进位 有的话再创建一个结点 没有得话直接返回开始创建的head 时间和空间都是O(max(n,m))的 
## 4.2 虚拟头节点
203 删除值为val的节点 设置一个虚拟头节点 然后从虚拟头节点的下一个节点开始遍历 如果等于val则跳过 否则遍历下一个节点

82  设置一个虚拟节点 对于当前节点cur 判断下一个和下两个节点是否相同 如果不同 cur后移 如果相同 找到第一个不同的节点 让cur->next指向它 

21 设置一个虚拟节点dummy 维护这个链表的尾节点tail 比较l1和l2 小的插入到tail后面 最后剩余一个元素再插入到tail后面
## 4.3 复杂的穿针引线
24  这题不能改变值 必须对结点进行交换 因此对于结点i j 必须修改他们的next指向 i可以指向j之后的结点 j可以指向i i前一个结点再指向j 因此必须维护一个指针pre始终指向交换的两个结点的前一个结点 当pre不存在或者pre后面的两个结点不存在时 退出循环 (后面有一个结点此时也不需要交换)

25 从head出发找到第一个不用翻转的结点tail 然后翻转[head,tail)中间的所有结点 同时维护head前一个结点pre (翻转任意ab两个结点 要先记录b后面的结点lst)  翻转完成后将翻转的部分重新连接到链表中 然后更新pre和head

147 按照插入排序的方法遍历链表 遍历到cur时 前面的结点都已经有序 用p遍历前面所有结点 p停在第一个大于cur的结点的前面 然后把cur插到p的后面即可 cur移动时后一个结点会丢失 提前用lst保存

148 nlogn的排序算法有快速排序 堆排序 归并排序 链表适合用归并排序 排序[head,tail) 当区间内没有或者只有一个结点时 直接返回 否则分为左右两段 对这两段再分别做归并排序 最后返回的两段都是排好序的 此时用合并有序链表的方法对这两段进行合并即可
## 4.4 不仅仅是穿针引线
237 对于要删除的结点node 如果他存在后继 并且 后继也存在后继 那么用后继覆盖它 然后后移node指针 当他只存在后继时 后继是最后一个结点 用这个结点覆盖他 再删除这个结点 node变为最后一个结点 指向空
## 4.5 链表与双指针
19  快慢指针 快指针从第n个节点开始 满指针从第0个节点开始 当快指针指向最后一个节点时 慢指针指向倒数第n个节点的前一个节点 然后删除第n个节点即可

61  找到tail指针 然后指向head 同时保存节点数n 右移k 即tail前移k 即tail后移(n-k%n) 此时tail下一个节点就是新的首节点 保存并把tail指向空

143 首先用快慢指针找到中间元素 然后以中间元素为界分为前面两段链表(中间元素属于前面) 然后反转后面的链表 然后合并两个链表即可

234 找到中间节点 分为前后两段链表(中间节点属于前面)  然后反转后面的链表 然后依次比较    空链表 单个节点 中间有多余节点 都是属于回文串
# 5.栈 队列 优先队列
## 5.1 栈的基础应用
20  首先括号数不能是单数 单数必不匹配；其次当遇到左括号时入栈，遇到右括号时，栈内必须要有元素而却栈顶元素必须和当前左括号匹配，否则匹配失败。最终要判断栈是否为空，如果还有括号剩下，说明右括号多了，依然匹配失败。

150 中缀表达式:( 1 + 2 ) * ( 3 + 4 ) 后缀表达式即逆波兰式( ( 1 2 + ) ( 3 4 + ) * )  特点:1.去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果  2. 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 (注意 1.s.top()返回栈顶元素 s.pop()栈顶出栈 返回空 2.c++11中int转string用to_string()  string转Int用stoi())

71

## 5.2 栈和递归的紧密关系
144

145

92

## 5.3 队列的典型应用
102

103

107

199

## 5.4 BFS和图的最短路径
279

127

126

286

## 5.5 优先队列
347

23
# 6.二叉树和递归
## 6.1 二叉树天然的递归结构
104 

111
## 6.2 简单的二叉树问题
226 

100

101

222

110

## 6.3 注意递归的终止条件
112

111

## 6.4 定义递归问题
257

113

129

222

## 6.5 稍复杂的递归逻辑
437

## 6.6 二叉搜索树中的问题
783 

235

98

108

230

236

# 7.递归和回溯法
## 7.1 树型问题
17

## 7.2 回溯
17

93

131

## 7.3 排列问题
46 

47

## 7.4 组合问题
77

## 7.5 回溯法解决组合问题的优化
77

39

40

216

78

90

## 7.6 二维平面上的回溯法
79

## 7.7 floodfill算法 
200

130

## 7.8 回溯再探 
51

52

37
# 8.动态规划基础
## 8.1 动态规划问题
70

120

64

## 8.2 发现重叠子问题
343

279

91

62

63

## 8.3 状态定义和状态转移
198

213

## 8.4 背包问题
416

139

## LIS问题
300
# 9.贪心算法
455

35.二分查找 如果没找到应该插入在l的位置 因为l左侧的值始终小于要找的数 r右侧的值始终大于要找的数 退出循环时l一定在r右侧 说明此时l的值是大于target的 r的值是小于target的 插在中间就是r+1或l
